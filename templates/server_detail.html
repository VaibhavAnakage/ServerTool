<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Server Detail - {{ server.name }}</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* Linux System Info polish */
    .lsi-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(340px, 1fr)); gap:16px; }
    .table { width:100%; border-collapse:collapse; table-layout: fixed; }
    .table thead th { text-align:left; padding:8px; background:#5b21b6; color:#fff; position:sticky; top:0; z-index:1; }
    .table tbody td { padding:8px; border-bottom:1px solid #e5e7eb; vertical-align:top; }
    .table-scroll { height:260px; overflow:auto; border:1px solid #e5e7eb; border-radius:8px; background:#fff; position:relative; }
    .kv-table td:first-child { width:140px; white-space:nowrap; }
    .kv-table td.wrap { white-space:pre-wrap; word-break:break-word; }
    .card > h3 { margin-top:0; }
    .badge { display:inline-block; padding:2px 8px; border-radius:9999px; font-size:12px; }
    .badge-danger { background:#fee2e2; color:#991b1b; }
    .badge-success { background:#dcfce7; color:#166534; }
    .mono { white-space:pre; height:260px; overflow:auto; border:1px solid #e5e7eb; border-radius:8px; background:#fff; padding:8px; }
    .truncate { overflow:hidden; text-overflow:ellipsis; white-space:nowrap; display:block; }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <h1>Server Detail: {{ server.name }}</h1>
    </div>
  </header>

  <nav>
    <div class="container">
      <ul>
        <li><a href="/">Dashboard</a></li>
        <li><a href="/server">Server Info</a></li>
        <li><a href="/server/history">Server History</a></li>
        <li style="margin-left:auto"><a href="/logout">Logout ({{ user.name if user else '' }})</a></li>
      </ul>
    </div>
  </nav>

  <div class="container">
    <div class="card">
      <h2>Overview</h2>
      <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 16px;">
        <div class="card">
          <h3>Identity</h3>
          <ul style="list-style:none; padding:0;">
            <li><strong>ID:</strong> {{ server.id }}</li>
            <li><strong>Name:</strong> {{ server.name }}</li>
            <li><strong>IP:</strong> {{ server.ip_address }}</li>
            <li><strong>Location:</strong> {{ server.location or '-' }}</li>
          </ul>
        </div>
        <div class="card">
          <h3>Status</h3>
          <ul style="list-style:none; padding:0;">
            <li><strong>Alive:</strong> {% if server.alive %}<span class="badge badge-success">Online</span>{% else %}<span class="badge badge-danger">Offline</span>{% endif %}</li>
            <li><strong>Last Ping:</strong> {{ server.last_ping_at or '-' }}</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>CPU & Memory Utilization</h2>
      <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:8px;">
        <label for="rangeSelect"><strong>Range:</strong></label>
        <select id="rangeSelect" class="form-control" style="min-width:140px;">
          <option value="60">Last 1 hour</option>
          <option value="360">Last 6 hours</option>
          <option value="1440" selected>Last 24 hours</option>
          <option value="10080">Last 7 days</option>
          <option value="">All</option>
        </select>
        <label for="limitInput"><strong>Max points:</strong></label>
        <input type="number" id="limitInput" class="form-control" value="500" min="50" max="5000" step="50" style="width:110px;">
        <button id="applyBtn" class="btn btn-primary">Apply</button>
        <label style="display:flex; align-items:center; gap:6px; margin-left:16px;">
          <input type="checkbox" id="autoRefreshCbx" checked>
          Auto-refresh (30s)
        </label>
      </div>
      <p id="series-note" style="margin-top:-6px; color:#666;">Loading time-series...</p>
      <div class="card" style="padding:8px;">
        <h3>CPU% and Memory% (combined)</h3>
        <canvas id="cmChart" width="800" height="400" style="width:800px;height:400px;display:block;"></canvas>
      </div>
    </div>

    <div class="card">
      <h2>Linux System Info</h2>
      <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:8px;">
        <span id="lsi-updated" style="color:#666;">Last updated: -</span>
        <label style="display:flex; align-items:center; gap:6px; margin-left:auto;">
          <input type="checkbox" id="lsiAutoRefreshCbx" checked>
          Auto-refresh (3m)
        </label>
        <button id="lsiRefreshBtn" class="btn btn-secondary">Refresh</button>
      </div>
      <div class="lsi-grid">
        <div class="card">
          <h3>Identity</h3>
          <div class="table-scroll">
          <table class="table kv-table">
            <tbody id="lsi-identity"></tbody>
          </table>
          </div>
        </div>
        <div class="card">
          <h3>System</h3>
          <div class="table-scroll">
          <table class="table kv-table">
            <tbody id="lsi-system"></tbody>
          </table>
          </div>
        </div>
        <div class="card">
          <h3>Disk Usage</h3>
          <div class="table-scroll">
            <table class="table">
              <thead><tr><th>FS</th><th>Type</th><th>Size</th><th>Used</th><th>Avail</th><th>Use%</th><th>Mount</th></tr></thead>
              <tbody id="lsi-disk"></tbody>
            </table>
          </div>
        </div>
        <div class="card">
          <h3>Top Memory Processes</h3>
          <div style="display:flex; gap:8px; align-items:center; margin-bottom:6px;">
            <input id="memFilter" class="form-control" placeholder="Filter command" style="min-width:200px;">
            <button class="btn btn-secondary" id="memSortCpu">Sort CPU</button>
            <button class="btn btn-secondary" id="memSortMem">Sort MEM</button>
          </div>
          <div class="table-scroll">
            <table class="table"><thead><tr><th>PID</th><th>CMD</th><th>%MEM</th><th>%CPU</th></tr></thead>
              <tbody id="lsi-proc-mem"></tbody></table>
          </div>
        </div>
        <div class="card">
          <h3>Top CPU Processes</h3>
          <div style="display:flex; gap:8px; align-items:center; margin-bottom:6px;">
            <input id="cpuFilter" class="form-control" placeholder="Filter command" style="min-width:200px;">
            <button class="btn btn-secondary" id="cpuSortCpu">Sort CPU</button>
            <button class="btn btn-secondary" id="cpuSortMem">Sort MEM</button>
          </div>
          <div class="table-scroll">
            <table class="table"><thead><tr><th>PID</th><th>CMD</th><th>%MEM</th><th>%CPU</th></tr></thead>
              <tbody id="lsi-proc-cpu"></tbody></table>
          </div>
        </div>
        <div class="card">
          <h3>Services</h3>
          <div style="display:flex; gap:8px; align-items:center; margin-bottom:6px;">
            <input id="svcFilter" class="form-control" placeholder="Filter service" style="min-width:200px;">
          </div>
          <div class="table-scroll">
            <table class="table"><thead><tr><th>Name</th><th>Loaded</th><th>Active</th><th>State</th></tr></thead>
              <tbody id="lsi-services"></tbody></table>
          </div>
        </div>
        <div class="card">
          <h3>Networking</h3>
          <pre id="lsi-net" class="mono" style="max-height:260px; overflow:auto;"></pre>
        </div>
        <div class="card">
          <h3>Listening Ports</h3>
          <pre id="lsi-ports" class="mono" style="max-height:260px; overflow:auto;"></pre>
        </div>
        <div class="card">
          <h3>Logged-in Users</h3>
          <pre id="lsi-users" class="mono" style="max-height:260px; overflow:auto;"></pre>
        </div>
        <div class="card">
          <h3>Mounted Filesystems (Raw)</h3>
          <pre id="lsi-mounts" class="mono" style="max-height:260px; overflow:auto;"></pre>
        </div>
        <div class="card">
          <h3>System Logs (Tail)</h3>
          <pre id="lsi-logs" class="mono" style="max-height:260px; overflow:auto;"></pre>
        </div>
      </div>
    </div>
  </div>

<script>
(function(){
  const serverId = {{ server.id | tojson }};
  const cmCtx = document.getElementById('cmChart').getContext('2d');
  const noteEl = document.getElementById('series-note');

  let cmChart;

  function mkLine(ctx, datasets) {
    return new Chart(ctx, {
      type: 'line',
      data: { labels: [], datasets },
      options: {
        responsive: false,
        maintainAspectRatio: false,
        elements: { point: { radius: 0 } },
        scales: {
          x: { ticks: { autoSkip: true, maxTicksLimit: 10 } },
          y: { beginAtZero: true, max: 100 }
        },
        plugins: { legend: { display: false } }
      }
    });
  }

  function fmtTs(ts) {
    return ts; // already formatted string from server
  }

  function upsertData(chart, labels, series) {
    chart.data.labels = labels;
    chart.data.datasets = series;
    chart.update();
  }

  async function fetchJson(url){
    const res = await fetch(url, { credentials:'same-origin' });
    if(!res.ok) throw new Error('HTTP '+res.status);
    return res.json();
  }

  async function loadData(){
    try{
      const limitEl = document.getElementById('limitInput');
      const rangeEl = document.getElementById('rangeSelect');
      const limit = Math.max(50, Math.min(5000, parseInt(limitEl.value || '500', 10)));
      const since = rangeEl.value;
      const sinceQS = since ? `&since_minutes=${encodeURIComponent(since)}` : '';

      const [linux, win] = await Promise.all([
        fetchJson(`/api/server-status/history?server_id=${serverId}&limit=${limit}${sinceQS}`).catch(()=>({points:[]})),
        fetchJson(`/api/server-status/history-windows?server_id=${serverId}&limit=${limit}${sinceQS}`).catch(()=>({points:[]})),
      ]);

      const lpts = linux.points || [];
      const wpts = win.points || [];

      const hasLinux = lpts.length > 0;
      const hasWindows = wpts.length > 0;

      if(!hasLinux && !hasWindows){
        noteEl.textContent = 'No time-series data found yet for this server.';
      } else if (hasLinux && hasWindows){
        noteEl.textContent = 'Showing both Linux and Windows series (if overlaps exist).';
      } else {
        noteEl.textContent = hasLinux ? 'Showing Linux series.' : 'Showing Windows series.';
      }

      // Build combined x-axis by union of timestamps
      const tsSet = new Set();
      lpts.forEach(p=>tsSet.add(p.ts));
      wpts.forEach(p=>tsSet.add(p.ts));
      const labels = Array.from(tsSet).sort();

      const lCpuMap = new Map(lpts.map(p=>[p.ts, p.cpu]));
      const wCpuMap = new Map(wpts.map(p=>[p.ts, p.cpu]));
      const lMemMap = new Map(lpts.map(p=>[p.ts, p.mem]));
      const wMemMap = new Map(wpts.map(p=>[p.ts, p.mem]));

      // Datasets
      const datasets = [];
      if(hasLinux){
        datasets.push({ label:'CPU Linux', data: labels.map(t=>lCpuMap.get(t) ?? null), borderColor:'#2563eb', backgroundColor:'rgba(37,99,235,0.15)', tension:0.25, spanGaps:true });
        datasets.push({ label:'Mem Linux', data: labels.map(t=>lMemMap.get(t) ?? null), borderColor:'#16a34a', backgroundColor:'rgba(22,163,74,0.15)', tension:0.25, spanGaps:true });
      }
      if(hasWindows){
        datasets.push({ label:'CPU Windows', data: labels.map(t=>wCpuMap.get(t) ?? null), borderColor:'#db2777', backgroundColor:'rgba(219,39,119,0.15)', tension:0.25, spanGaps:true });
        datasets.push({ label:'Mem Windows', data: labels.map(t=>wMemMap.get(t) ?? null), borderColor:'#f59e0b', backgroundColor:'rgba(245,158,11,0.15)', tension:0.25, spanGaps:true });
      }
      if(!cmChart) cmChart = mkLine(cmCtx, datasets);
      upsertData(cmChart, labels.map(fmtTs), datasets);

    }catch(e){
      noteEl.textContent = 'Failed to load time-series data.';
    }
  }

  loadData();

  // Apply button triggers reload
  document.getElementById('applyBtn').addEventListener('click', function(){
    loadData();
  });

  // Auto-refresh every 30s when enabled
  setInterval(function(){
    const cb = document.getElementById('autoRefreshCbx');
    if(cb && cb.checked){ loadData(); }
  }, 30000);

  // ---------------- Linux System Info Renderer ----------------
  const lsi = {
    serverId: {{ server.id | tojson }},
    raw: null,
    parsed: null,
  };

  function setUpdated(ts){
    const el = document.getElementById('lsi-updated');
    if(el) el.textContent = 'Last updated: ' + (ts || '-');
  }

  function kvRow(k,v){ return `<tr><td><strong>${k}</strong></td><td class="wrap">${(v||'').toString().replace(/</g,'&lt;')}</td></tr>`; }

  function parseDf(text){
    const rows = [];
    (text||'').split(/\n/).forEach(line=>{
      const m = line.match(/^(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)%\s+(\S+)/);
      if(m){
        rows.push({fs:m[1], type:m[2], size:m[3], used:m[4], avail:m[5], usep:parseInt(m[6],10)||0, mount:m[7]});
      }
    });
    return rows;
  }

  function renderDf(rows){
    const tb = document.getElementById('lsi-disk');
    tb.innerHTML = rows.map(r=>`<tr class="${r.usep>=80?'bad':''}"><td>${r.fs}</td><td>${r.type}</td><td>${r.size}</td><td>${r.used}</td><td>${r.avail}</td><td>${r.usep}%</td><td>${r.mount}</td></tr>`).join('');
  }

  function parsePs(text){
    // Supports: pid ppid cmd %mem %cpu (cmd may contain spaces)
    const out=[];
    (text||'').split(/\n/).forEach(line=>{
      const m = line.trim().match(/^(\d+)\s+(\d+)\s+(.*?)\s+([0-9.]+)\s+([0-9.]+)$/);
      if(m){ out.push({pid:m[1], cmd:m[3], mem:parseFloat(m[4])||0, cpu:parseFloat(m[5])||0}); }
    });
    return out;
  }

  function renderPs(rows, tbodyId){
    const f = document.getElementById(tbodyId.replace('lsi-proc','').toLowerCase().includes('mem')? 'memFilter':'cpuFilter');
    const term = (f&&f.value||'').toLowerCase();
    const tb = document.getElementById(tbodyId);
    tb.innerHTML = rows
      .filter(r=>!term || r.cmd.toLowerCase().includes(term))
      .map(r=>`<tr><td style="width:70px;">${r.pid}</td><td title="${r.cmd}"><span class="truncate">${r.cmd}</span></td><td style="width:80px;">${r.mem}</td><td style="width:80px;">${r.cpu}</td></tr>`)
      .join('');
  }

  function parseServices(text){
    const rows = [];
    (text||'').split(/\n/).forEach(line=>{
      if(/^\s*UNIT\b/i.test(line)) return; // skip header row from systemctl output
      const m = line.match(/^(\S+)\s+loaded\s+(\S+)\s+(\S+)\s+(\S+)/i);
      if(m){
        rows.push({name:m[1], loaded:m[2], active:m[3], state:m[4]});
      } else if(line.trim()) {
        // Fallback: try split tokens
        const parts = line.trim().split(/\s+/);
        rows.push({name:parts[0]||'', loaded:parts[1]||'', active:parts[2]||'', state:parts[3]||''});
      }
    });
    return rows;
  }

  function renderServices(rows){
    const term = (document.getElementById('svcFilter').value||'').toLowerCase();
    const tb = document.getElementById('lsi-services');
    tb.innerHTML = rows.filter(r=>!term || r.name.toLowerCase().includes(term))
      .map(r=>`<tr><td>${r.name}</td><td>${r.loaded}</td><td>${r.active}</td><td>${r.state}</td></tr>`).join('');
  }

  function renderIdentity(d){
    const rows = [];
    rows.push(kvRow('Date/Time', d.date_time));
    rows.push(kvRow('Hostname', d.hostname));
    rows.push(kvRow('Kernel', d.kernel_version));
    rows.push(kvRow('Architecture', d.architecture));
    document.getElementById('lsi-identity').innerHTML = rows.join('');
  }

  function renderSystem(d){
    const rows = [];
    rows.push(kvRow('OS Info', d.os_info));
    rows.push(kvRow('Uptime', d.uptime));
    // Memory warning if usage >80% (best effort parse of "used/total")
    let memLine = d.memory_usage||'';
    let memWarn = '';
    const m = memLine.match(/\b(\d+)\s+(\d+)\s+(\d+)/); // naive numbers: total used free
    if(m){
      const total = parseFloat(m[1]); const used = parseFloat(m[2]);
      if(total>0){ const pct = Math.round((used/total)*100); memWarn = pct>=80?` <span class='badge badge-danger'>${pct}%</span>`:` <span class='badge badge-success'>${pct}%</span>`; }
    }
    rows.push(kvRow('Memory Usage', memLine + memWarn));
    document.getElementById('lsi-system').innerHTML = rows.join('');
  }

  async function loadLsi(){
    try{
      const res = await fetch(`/api/linux-system-info?server_id=${lsi.serverId}`, {credentials:'same-origin'});
      if(!res.ok){ setUpdated('-'); return; }
      const j = await res.json();
      if(!j.exists){ setUpdated('-'); return; }
      setUpdated(j.created_at);
      const d = j.data || {};
      renderIdentity(d);
      renderSystem(d);
      renderDf(parseDf(d.disk_usage||''));
      // Store raw process text for filtering/sorting
      document.getElementById('lsi-proc-mem').dataset.raw = d.top_memory_processes||'';
      document.getElementById('lsi-proc-cpu').dataset.raw = d.top_cpu_processes||'';
      renderPs(parsePs(d.top_memory_processes||''), 'lsi-proc-mem');
      renderPs(parsePs(d.top_cpu_processes||''), 'lsi-proc-cpu');
      document.getElementById('lsi-net').textContent = d.network_interfaces||'';
      document.getElementById('lsi-ports').textContent = d.listening_ports||'';
      document.getElementById('lsi-users').textContent = d.logged_in_users||'';
      document.getElementById('lsi-mounts').textContent = d.mounted_filesystems||'';
      document.getElementById('lsi-logs').textContent = d.system_logs||'';
      // Services
      const svcRows = parseServices(d.running_services||'');
      document.getElementById('lsi-services').dataset.raw = d.running_services||'';
      renderServices(svcRows);
    }catch(e){ setUpdated('-'); }
  }

  // Event handlers for filters/sorts
  document.getElementById('memFilter').addEventListener('input', ()=>{
    renderPs(parsePs(document.getElementById('lsi-proc-mem').dataset.raw||''), 'lsi-proc-mem');
  });
  document.getElementById('cpuFilter').addEventListener('input', ()=>{
    renderPs(parsePs(document.getElementById('lsi-proc-cpu').dataset.raw||''), 'lsi-proc-cpu');
  });
  document.getElementById('memSortCpu').addEventListener('click', ()=>{
    const rows = parsePs(document.getElementById('lsi-proc-mem').dataset.raw||'').sort((a,b)=>b.cpu-a.cpu);
    renderPs(rows, 'lsi-proc-mem');
  });
  document.getElementById('memSortMem').addEventListener('click', ()=>{
    const rows = parsePs(document.getElementById('lsi-proc-mem').dataset.raw||'').sort((a,b)=>b.mem-a.mem);
    renderPs(rows, 'lsi-proc-mem');
  });
  document.getElementById('cpuSortCpu').addEventListener('click', ()=>{
    const rows = parsePs(document.getElementById('lsi-proc-cpu').dataset.raw||'').sort((a,b)=>b.cpu-a.cpu);
    renderPs(rows, 'lsi-proc-cpu');
  });
  document.getElementById('cpuSortMem').addEventListener('click', ()=>{
    const rows = parsePs(document.getElementById('lsi-proc-cpu').dataset.raw||'').sort((a,b)=>b.mem-a.mem);
    renderPs(rows, 'lsi-proc-cpu');
  });
  document.getElementById('svcFilter').addEventListener('input', ()=>{
    const rows = parseServices(document.getElementById('lsi-services').dataset.raw||'');
    renderServices(rows);
  });
  document.getElementById('lsiRefreshBtn').addEventListener('click', loadLsi);

  // initial load + auto-refresh every 3 minutes
  loadLsi();
  setInterval(()=>{
    const cb = document.getElementById('lsiAutoRefreshCbx');
    if(cb && cb.checked){ loadLsi(); }
  }, 180000);
})();
</script>
</body>
</html>
